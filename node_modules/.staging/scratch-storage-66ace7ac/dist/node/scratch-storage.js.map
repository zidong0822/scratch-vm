{"version":3,"file":"scratch-storage.js","sources":["webpack://ScratchStorage/webpack/bootstrap","webpack://ScratchStorage/./src/builtins/defaultBitmap.png","webpack://ScratchStorage/./src/builtins/defaultSound.wav","webpack://ScratchStorage/./src/builtins/defaultVector.svg","webpack://ScratchStorage/./node_modules/arraybuffer-loader/lib/to-array-buffer.js","webpack://ScratchStorage/src/Asset.js","webpack://ScratchStorage/src/AssetType.js","webpack://ScratchStorage/src/BuiltinHelper.js","webpack://ScratchStorage/src/DataFormat.js","webpack://ScratchStorage/src/Helper.js","webpack://ScratchStorage/src/LocalHelper.js","webpack://ScratchStorage/src/ScratchStorage.js","webpack://ScratchStorage/src/WebHelper.js","webpack://ScratchStorage/src/index.js","webpack://ScratchStorage/external \"base64-js\"","webpack://ScratchStorage/external \"js-md5\"","webpack://ScratchStorage/external \"localforage\"","webpack://ScratchStorage/external \"nets\"","webpack://ScratchStorage/external \"text-encoding\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","module.exports = require(\"../../node_modules/arraybuffer-loader/lib/to-array-buffer.js\")(\"iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAAAAADmVT4XAAADZElEQVR42u3a70vbQBgH8O/7vOibvsmbFUEEWUGGUhQ25nDuhSKIUFDxlYi0SAd94atRmFiHCH2x4W8iiNtwowXRgd1QipJYY3N/1F4kTQ6XLKS9yyHcvWyO8MnT5y53Tw5EcIMESIAESIAESIAESIAEPFVAq/6l8G4oAQCp4aniwbUVJ6BVzafwqKXy1VZMgNb+CHzbyK4ZB+Bi0nnk0VyhsDiSoAmvvnMHmGUVAF6UG+0ffsxRhsRHky/AyCsAUpumX0wAAIs6T4CxDADDtcdZsal6gjmdH8AsAEC6+s8Fa48SFExeAKusAEju+V367AmUCi9ANQ0AU3pwcOw2cMEH0FwAAKz5X228pRLR5AI4TgIAtIDL24oLUE94AB6W7LsH/cONN14Ilh44AOqD9s2LQR1KHiB9zgGgOSGeuA3ocPrME1Q4ANaceyePAzrcjHmAZYs9IBeW4/fzHiAwTCwAgTle9ACZK44ALDT9e6x7gL4aT0BQCHb4AqgA5/1TTOMLoJ7vZSMM0H/GHnCeDnu+CrU8vGYPcN5FADBYD0vCaYPDy+i0p337GSMsS1Z4vA3t9QgAZTt0IuIxFRPSKicAQHlvhk3FXF5GhBByMa8qo/sBO6BarwuYbYrYnFKDYEvE7phKgcxvEQBqnvhgiQCUOgoAO4C3JOS3L/hv23UXxVldBECfcueAqpAa0WGy/QeULREAY6aTXRFDgBuA13+ElOncAERMAGaA9hBQD4gQQHsIRE1AZoD2xrgQS5nOZyHgFKmWDSIG4GRAVidiAE4GRB6AzAB2AKIPQFaA5myHA5AV4ESNugZhC7BLR50lIBPAebrzBGQCKAFQNSIMcDvRTQIwAHxNApM3RBygGK0uyhxwOwGsPAgEnPWj5ycRCNiJtBHlAChGKQVwANzPY+CXSMDNWISiLA9AfRA5IhJQ68UnoQAt+AtOPIBKhJosF8B6UM0yLkAxQk2WCyDX9SiUh1gkQAIkoCuAvjGuquMbuijAtwG7MPL8yBICOHSPk3W8Ne8KcEUdmBi6FADYos+QleIH0N/ogOxd7AD6uAS6WRU8WcBdlgZMG/EnYUlwEpLLoQ4PjzGbiA5UsRMRsbQ+5ziDJmYqJuR6NaMomdXuFuZyPSABEiABEiABEiABEiAc8Bd6VyvCEKGqcQAAAABJRU5ErkJggg==\")","module.exports = require(\"../../node_modules/arraybuffer-loader/lib/to-array-buffer.js\")(\"UklGRiYAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQIAAAAAAA==\")","module.exports = require(\"../../node_modules/arraybuffer-loader/lib/to-array-buffer.js\")(\"PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxzdmcgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8Zz4KICA8cmVjdCBmaWxsPSIjQ0NDIiBoZWlnaHQ9IjEyOCIgd2lkdGg9IjEyOCIvPgogIDx0ZXh0IGZpbGw9ImJsYWNrIiB5PSIxMDciIHg9IjM1LjUiIGZvbnQtc2l6ZT0iMTI4Ij4/PC90ZXh0PgogPC9nPgo8L3N2Zz4K\")","'use strict'\n\nmodule.exports = function (base64Data) {\n  var isBrowser = typeof window !== 'undefined' && typeof window.atob === 'function'\n  var binary = isBrowser ? window.atob(base64Data) : new Buffer(base64Data, 'base64').toString('binary')\n  var bytes = new Uint8Array(binary.length)\n\n  for (var i = 0; i < binary.length; ++i) {\n    bytes[i] = binary.charCodeAt(i)\n  }\n\n  return bytes.buffer\n}\n","const TextDecoder = require('text-encoding').TextDecoder;\nconst TextEncoder = require('text-encoding').TextEncoder;\nconst base64js = require('base64-js');\n\nconst memoizedToString = (function () {\n    const strings = {};\n    return (assetId, data) => {\n        if (!strings.hasOwnProperty(assetId)) {\n            strings[assetId] = base64js.fromByteArray(data);\n        }\n        return strings[assetId];\n    };\n}());\n\nclass Asset {\n    /**\n     * Construct an Asset.\n     * @param {AssetType} assetType - The type of this asset (sound, image, etc.)\n     * @param {string} assetId - The ID of this asset.\n     * @param {DataFormat} [dataFormat] - The format of the data (WAV, PNG, etc.); required iff `data` is present.\n     * @param {Buffer} [data] - The in-memory data for this asset; optional.\n     */\n    constructor (assetType, assetId, dataFormat, data) {\n        /** @type {AssetType} */\n        this.assetType = assetType;\n\n        /** @type {string} */\n        this.assetId = assetId;\n\n        this.setData(data, dataFormat || assetType.runtimeFormat);\n\n        /** @type {Asset[]} */\n        this.dependencies = [];\n    }\n\n    setData (data, dataFormat) {\n        if (data && !dataFormat) {\n            throw new Error('Data provided without specifying its format');\n        }\n\n        /** @type {DataFormat} */\n        this.dataFormat = dataFormat;\n\n        /** @type {Buffer} */\n        this.data = data;\n    }\n\n    /**\n     * @returns {string} - This asset's data, decoded as text.\n     */\n    decodeText () {\n        const decoder = new TextDecoder();\n        return decoder.decode(this.data);\n    }\n\n    /**\n     * Same as `setData` but encodes text first.\n     * @param {string} data - the text data to encode and store.\n     * @param {DataFormat} dataFormat - the format of the data (DataFormat.SVG for example).\n     */\n    encodeTextData (data, dataFormat) {\n        const encoder = new TextEncoder();\n        this.setData(encoder.encode(data), dataFormat);\n    }\n\n    /**\n     * @param {string} [contentType] - Optionally override the content type to be included in the data URI.\n     * @returns {string} - A data URI representing the asset's data.\n     */\n    encodeDataURI (contentType) {\n        contentType = contentType || this.assetType.contentType;\n        return `data:${contentType};base64,${memoizedToString(this.assetId, this.data)}`;\n    }\n}\n\nmodule.exports = Asset;\n","const DataFormat = require('./DataFormat');\n\n/**\n * Enumeration of the supported asset types.\n * @type {Object.<String,AssetType>}\n * @typedef {Object} AssetType - Information about a supported asset type.\n * @property {string} contentType - the MIME type associated with this kind of data. Useful for data URIs, etc.\n * @property {string} name - The human-readable name of this asset type.\n * @property {DataFormat} runtimeFormat - The default format used for runtime, in-memory storage of this asset. For\n *     example, a project stored in SB2 format on disk will be returned as JSON when loaded into memory.\n * @property {boolean} immutable - Indicates if the asset id is determined by the asset content.\n */\nconst AssetType = {\n    ImageBitmap: {\n        contentType: 'image/png',\n        name: 'ImageBitmap',\n        runtimeFormat: DataFormat.PNG,\n        immutable: true\n    },\n    ImageVector: {\n        contentType: 'image/svg+xml',\n        name: 'ImageVector',\n        runtimeFormat: DataFormat.SVG,\n        immutable: true\n    },\n    Project: {\n        contentType: 'application/json',\n        name: 'Project',\n        runtimeFormat: DataFormat.JSON,\n        immutable: false\n    },\n    Sound: {\n        contentType: 'audio/x-wav',\n        name: 'Sound',\n        runtimeFormat: DataFormat.WAV,\n        immutable: true\n    },\n    Sprite: {\n        contentType: 'application/json',\n        name: 'Sprite',\n        runtimeFormat: DataFormat.JSON,\n        immutable: true\n    }\n};\n\nmodule.exports = AssetType;\n","const md5 = require('js-md5');\n\nconst Asset = require('./Asset');\nconst AssetType = require('./AssetType');\nconst DataFormat = require('./DataFormat');\nconst Helper = require('./Helper');\n\n/**\n * @typedef {object} BuiltinAssetRecord\n * @property {AssetType} type - The type of the asset.\n * @property {DataFormat} format - The format of the asset's data.\n * @property {?string} id - The asset's unique ID.\n * @property {Buffer} data - The asset's data.\n */\n\n/**\n * @type {BuiltinAssetRecord[]}\n */\nconst DefaultAssets = [\n    {\n        type: AssetType.ImageBitmap,\n        format: DataFormat.PNG,\n        id: null,\n        data: new Buffer(\n            require('arraybuffer-loader!./builtins/defaultBitmap.png') // eslint-disable-line global-require\n        )\n    },\n    {\n        type: AssetType.Sound,\n        format: DataFormat.WAV,\n        id: null,\n        data: new Buffer(\n            require('arraybuffer-loader!./builtins/defaultSound.wav') // eslint-disable-line global-require\n        )\n    },\n    {\n        type: AssetType.ImageVector,\n        format: DataFormat.SVG,\n        id: null,\n        data: new Buffer(\n            require('arraybuffer-loader!./builtins/defaultVector.svg') // eslint-disable-line global-require\n        )\n    }\n];\n\n/**\n * @type {BuiltinAssetRecord[]}\n */\nconst BuiltinAssets = DefaultAssets.concat([\n]);\n\nclass BuiltinHelper extends Helper {\n    constructor (parent) {\n        super(parent);\n\n        /**\n         * In-memory storage for all built-in assets.\n         * @type {Object.<AssetType, AssetIdMap>} Maps asset type to a map of asset ID to actual assets.\n         * @typedef {Object.<string, BuiltinAssetRecord>} AssetIdMap - Maps asset ID to asset.\n         */\n        this.assets = {};\n\n        BuiltinAssets.forEach(assetRecord => {\n            assetRecord.id = this.cache(assetRecord.type, assetRecord.format, assetRecord.data, assetRecord.id);\n        });\n    }\n\n    /**\n     * Call `setDefaultAssetId` on the parent `ScratchStorage` instance to register all built-in default assets.\n     */\n    registerDefaultAssets () {\n        const numAssets = DefaultAssets.length;\n        for (let assetIndex = 0; assetIndex < numAssets; ++assetIndex) {\n            const assetRecord = DefaultAssets[assetIndex];\n            this.parent.setDefaultAssetId(assetRecord.type, assetRecord.id);\n        }\n    }\n\n\n    /**\n     * Synchronously fetch a cached asset for a given asset id. Returns null if not found.\n     * @param {string} assetId - The id for the asset to fetch.\n     * @returns {?Asset} The asset for assetId, if it exists.\n     */\n    get (assetId) {\n        let asset = null;\n        if (this.assets.hasOwnProperty(assetId)) {\n            /** @type{BuiltinAssetRecord} */\n            const assetRecord = this.assets[assetId];\n            asset = new Asset(assetRecord.type, assetRecord.id, assetRecord.format, assetRecord.data);\n        }\n        return asset;\n    }\n\n    /**\n     * Cache an asset for future lookups by ID.\n     * @param {AssetType} assetType - The type of the asset to cache.\n     * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.\n     * @param {Buffer} data - The data for the cached asset.\n     * @param {string} id - The id for the cached asset.\n     * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.\n     */\n    cache (assetType, dataFormat, data, id) {\n        if (!dataFormat) throw new Error('Data cached without specifying its format');\n        if (id) {\n            if (this.assets.hasOwnProperty(id) && assetType.immutable) return id;\n        } else if (assetType.immutable) {\n            id = md5(data);\n        }\n        this.assets[id] = {\n            type: assetType,\n            format: dataFormat,\n            id: id,\n            data: data\n        };\n        return id;\n    }\n\n    /**\n     * Fetch an asset but don't process dependencies.\n     * @param {AssetType} assetType - The type of asset to fetch.\n     * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @return {Promise.<Asset>} A promise for the contents of the asset.\n     */\n    load (assetType, assetId) {\n        return Promise.resolve(this.get(assetId));\n    }\n}\n\nmodule.exports = BuiltinHelper;\n","/**\n * Enumeration of the supported data formats.\n * @enum {string}\n */\nconst DataFormat = {\n    JPG: 'jpg',\n    JSON: 'json',\n    MP3: 'mp3',\n    PNG: 'png',\n    SB2: 'sb2',\n    SVG: 'svg',\n    WAV: 'wav'\n};\n\nmodule.exports = DataFormat;\n","/**\n * Base class for asset load/save helpers.\n * @abstract\n */\nclass Helper {\n    constructor (parent) {\n        this.parent = parent;\n    }\n\n    /**\n     * Fetch an asset but don't process dependencies.\n     * @param {AssetType} assetType - The type of asset to fetch.\n     * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.\n     * @return {Promise.<Asset>} A promise for the contents of the asset.\n     */\n    load (assetType, assetId, dataFormat) {\n        return Promise.reject(new Error(`No asset of type ${assetType} for ID ${assetId} with format ${dataFormat}`));\n    }\n}\n\nmodule.exports = Helper;\n","const localforage = require('localforage');\n\nconst Asset = require('./Asset');\nconst Helper = require('./Helper');\n\n/**\n * Implements storage on the local device, available even when the device has no network connection.\n */\nclass LocalHelper extends Helper {\n\n    constructor (parent) {\n        super(parent);\n\n        localforage.config({\n            name: 'Scratch 3.0',\n            size: 100 * 1024 * 1024\n        });\n    }\n\n    /**\n     * Fetch an asset but don't process dependencies.\n     * @param {AssetType} assetType - The type of asset to fetch.\n     * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.\n     * @return {Promise.<Asset>} A promise for the contents of the asset.\n     */\n    load (assetType, assetId, dataFormat) {\n        return new Promise((fulfill, reject) => {\n            const fileName = [assetId, dataFormat].join('.');\n            localforage.getItem(fileName).then(\n                data => {\n                    if (data === null) {\n                        fulfill(null);\n                    } else {\n                        fulfill(new Asset(assetType, assetId, dataFormat, data));\n                    }\n                },\n                error => {\n                    reject(error);\n                });\n        });\n    }\n}\n\nmodule.exports = LocalHelper;\n","const BuiltinHelper = require('./BuiltinHelper');\nconst LocalHelper = require('./LocalHelper');\nconst WebHelper = require('./WebHelper');\n\nconst _Asset = require('./Asset');\nconst _AssetType = require('./AssetType');\nconst _DataFormat = require('./DataFormat');\n\nclass ScratchStorage {\n    constructor () {\n        this.defaultAssetId = {};\n\n        this.builtinHelper = new BuiltinHelper(this);\n        this.webHelper = new WebHelper(this);\n        this.localHelper = new LocalHelper(this);\n\n        this.builtinHelper.registerDefaultAssets(this);\n    }\n\n    /**\n     * @return {Asset} - the `Asset` class constructor.\n     * @constructor\n     */\n    get Asset () {\n        return _Asset;\n    }\n\n    /**\n     * @return {AssetType} - the list of supported asset types.\n     * @constructor\n     */\n    get AssetType () {\n        return _AssetType;\n    }\n\n    /**\n     * @return {DataFormat} - the list of supported data formats.\n     * @constructor\n     */\n    get DataFormat () {\n        return _DataFormat;\n    }\n\n    /**\n     * @deprecated Please use the `Asset` member of a storage instance instead.\n     * @return {Asset} - the `Asset` class constructor.\n     * @constructor\n     */\n    static get Asset () {\n        return _Asset;\n    }\n\n    /**\n     * @deprecated Please use the `AssetType` member of a storage instance instead.\n     * @return {AssetType} - the list of supported asset types.\n     * @constructor\n     */\n    static get AssetType () {\n        return _AssetType;\n    }\n\n    /**\n     * Synchronously fetch a cached asset from built-in storage. Assets are cached when they are loaded.\n     * @param {string} assetId - The id of the asset to fetch.\n     * @returns {?Asset} The asset, if it exists.\n     */\n    get (assetId) {\n        return this.builtinHelper.get(assetId);\n    }\n\n    /**\n     * Cache an asset for future lookups by ID.\n     * @param {AssetType} assetType - The type of the asset to cache.\n     * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.\n     * @param {Buffer} data - The data for the cached asset.\n     * @param {string} id - The id for the cached asset.\n     * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.\n     */\n    cache (assetType, dataFormat, data, id) {\n        return this.builtinHelper.cache(assetType, dataFormat, data, id);\n    }\n\n    /**\n     * Register a web-based source for assets. Sources will be checked in order of registration.\n     * @param {Array.<AssetType>} types - The types of asset provided by this source.\n     * @param {UrlFunction} urlFunction - A function which computes a URL from an Asset.\n     */\n    addWebSource (types, urlFunction) {\n        this.webHelper.addSource(types, urlFunction);\n    }\n\n    /**\n     * TODO: Should this be removed in favor of requesting an asset with `null` as the ID?\n     * @param {AssetType} type - Get the default ID for assets of this type.\n     * @return {?string} The ID of the default asset of the given type, if any.\n     */\n    getDefaultAssetId (type) {\n        if (this.defaultAssetId.hasOwnProperty(type.name)) {\n            return this.defaultAssetId[type.name];\n        }\n    }\n\n    /**\n     * Set the default ID for a particular type of asset. This default asset will be used if a requested asset cannot\n     * be found and automatic fallback is enabled. Ideally this should be an asset that is available locally or even\n     * one built into this module.\n     * TODO: Should this be removed in favor of requesting an asset with `null` as the ID?\n     * @param {AssetType} type - The type of asset for which the default will be set.\n     * @param {string} id - The default ID to use for this type of asset.\n     */\n    setDefaultAssetId (type, id) {\n        this.defaultAssetId[type.name] = id;\n    }\n\n    /**\n     * Fetch an asset by type & ID.\n     * @param {AssetType} assetType - The type of asset to fetch. This also determines which asset store to use.\n     * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @param {DataFormat} [dataFormat] - Optional: load this format instead of the AssetType's default.\n     * @return {Promise.<Asset>} A promise for the requested Asset.\n     *   If the promise is fulfilled with non-null, the value is the requested asset or a fallback.\n     *   If the promise is fulfilled with null, the desired asset could not be found with the current asset sources.\n     *   If the promise is rejected, there was an error on at least one asset source. HTTP 404 does not count as an\n     *   error here, but (for example) HTTP 403 does.\n     */\n    load (assetType, assetId, dataFormat) {\n        /** @type {Helper[]} */\n        const helpers = [this.builtinHelper, this.localHelper, this.webHelper];\n        const errors = [];\n        let helperIndex = 0;\n        dataFormat = dataFormat || assetType.runtimeFormat;\n\n        return new Promise((fulfill, reject) => {\n            const tryNextHelper = () => {\n                if (helperIndex < helpers.length) {\n                    const helper = helpers[helperIndex++];\n                    helper.load(assetType, assetId, dataFormat)\n                        .then(\n                            asset => {\n                                if (asset === null) {\n                                    tryNextHelper();\n                                } else {\n                                    // TODO? this.localHelper.cache(assetType, assetId, asset);\n                                    if (helper !== this.builtinHelper && assetType.immutable) {\n                                        asset.assetId = this.builtinHelper.cache(\n                                            assetType,\n                                            asset.dataFormat,\n                                            asset.data,\n                                            assetId\n                                        );\n                                    }\n                                    // Note that other attempts may have caused errors, effectively suppressed here.\n                                    fulfill(asset);\n                                }\n                            },\n                            error => {\n                                errors.push(error);\n                                // TODO: maybe some types of error should prevent trying the next helper?\n                                tryNextHelper();\n                            }\n                        );\n                } else if (errors.length === 0) {\n                    // Nothing went wrong but we couldn't find the asset.\n                    fulfill(null);\n                } else {\n                    // At least one thing went wrong and also we couldn't find the asset.\n                    reject(errors);\n                }\n            };\n\n            tryNextHelper();\n        });\n    }\n}\n\nmodule.exports = ScratchStorage;\n","const nets = require('nets');\n\nconst Asset = require('./Asset');\nconst Helper = require('./Helper');\n\n/**\n * @typedef {function} UrlFunction - A function which computes a URL from asset information.\n * @param {Asset} - The asset for which the URL should be computed.\n * @returns {string} - The URL for the asset.\n */\n\nclass WebHelper extends Helper {\n    constructor (parent) {\n        super(parent);\n\n        /**\n         * @type {Array.<SourceRecord>}\n         * @typedef {object} SourceRecord\n         * @property {Array.<string>} types - The types of asset provided by this source, from AssetType's name field.\n         * @property {UrlFunction} urlFunction - A function which computes a URL from an Asset.\n         */\n        this.sources = [];\n    }\n\n    /**\n     * Register a web-based source for assets. Sources will be checked in order of registration.\n     * @param {Array.<AssetType>} types - The types of asset provided by this source.\n     * @param {UrlFunction} urlFunction - A function which computes a URL from an Asset.\n     */\n    addSource (types, urlFunction) {\n        this.sources.push({\n            types: types.map(assetType => assetType.name),\n            urlFunction: urlFunction\n        });\n    }\n\n    /**\n     * Fetch an asset but don't process dependencies.\n     * @param {AssetType} assetType - The type of asset to fetch.\n     * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.\n     * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.\n     * @return {Promise.<Asset>} A promise for the contents of the asset.\n     */\n    load (assetType, assetId, dataFormat) {\n\n        /** @type {Array.<{url:string, result:*}>} List of URLs attempted & errors encountered. */\n        const errors = [];\n        const sources = this.sources.slice();\n        const asset = new Asset(assetType, assetId, dataFormat);\n        let sourceIndex = 0;\n\n        return new Promise((fulfill, reject) => {\n\n            const tryNextSource = () => {\n\n                /** @type {UrlFunction} */\n                let urlFunction;\n\n                while (sourceIndex < sources.length) {\n                    const source = sources[sourceIndex];\n                    ++sourceIndex;\n                    if (source.types.indexOf(assetType.name) >= 0) {\n                        urlFunction = source.urlFunction;\n                        break;\n                    }\n                }\n\n                if (urlFunction) {\n                    const url = urlFunction(asset);\n                    if (url === false) {\n                        tryNextSource();\n                        return;\n                    }\n\n                    nets({url: url}, (err, resp, body) => {\n                        // body is a Buffer\n                        if (err || Math.floor(resp.statusCode / 100) !== 2) {\n                            tryNextSource();\n                        } else {\n                            asset.setData(body, dataFormat);\n                            fulfill(asset);\n                        }\n                    });\n                } else if (errors.length > 0) {\n                    reject(errors);\n                } else {\n                    fulfill(null); // no sources matching asset\n                }\n            };\n\n            tryNextSource();\n        });\n    }\n}\n\nmodule.exports = WebHelper;\n","const ScratchStorage = require('./ScratchStorage');\n\n/**\n * Export for use with NPM & Node.js.\n * @type {ScratchStorage}\n */\nmodule.exports = ScratchStorage;\n","module.exports = require(\"base64-js\");","module.exports = require(\"js-md5\");","module.exports = require(\"localforage\");","module.exports = require(\"nets\");","module.exports = require(\"text-encoding\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;AC3EA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAzBA;AACA;AAgCA;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;;;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAJA;AASA;AACA;AACA;AACA;AAAA;AAJA;AASA;AACA;AACA;AACA;AAAA;AAJA;AACA;AASA;;;AAGA;AACA;AAEA;;;AACA;AAAA;AACA;AAEA;;;;;AAHA;AACA;AAOA;AACA;AACA;AACA;AACA;AAZA;AAaA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;;;AA3EA;AACA;AA6EA;;;;;;;;;;;;;;ACjIA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AASA;;;;;;;;;;;;;;;;;;ACdA;;;;AAIA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;;;AAGA;;;AAEA;AAAA;AACA;AADA;AACA;AAEA;AACA;AACA;AAFA;AAHA;AAOA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAjCA;AACA;AAmCA;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AA0CA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AArJA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;;;;AAoHA;;;;;;;;;;;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;AACA;AAAA;AACA;AAEA;;;;;;AAHA;AACA;AAQA;AATA;AAUA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AAIA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAjFA;AACA;AAmFA;;;;;;;;;;;;;;AC/FA;AACA;AACA;;;;AAIA;;;;;;;;;;;ACNA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}